<!DOCTYPE html>
<html  >
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Mobirise v5.6.5, mobirise.com">
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:image:src" content="">
  <meta property="og:image" content="">
  <meta name="twitter:title" content="AI">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <link rel="shortcut icon" href="assets/images/school-logo-create-outline-96x119.png" type="image/x-icon">
  <meta name="description" content="">
  
  <title>中國皮影戲遊戲</title>
  <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="assets/bootstrap/css/bootstrap-grid.min.css">
  <link rel="stylesheet" href="assets/bootstrap/css/bootstrap-reboot.min.css">
  <link rel="stylesheet" href="assets/dropdown/css/style.css">
  <link rel="stylesheet" href="assets/socicon/css/styles.css">
  <link rel="stylesheet" href="assets/theme/css/style.css">
  <link rel="preload" href="https://fonts.googleapis.com/css?family=Xanh+Mono:400,400i&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Xanh+Mono:400,400i&display=swap"></noscript>
  <link rel="preload" href="https://fonts.googleapis.com/css?family=Tenor+Sans:400&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Tenor+Sans:400&display=swap"></noscript>
  <link rel="preload" as="style" href="assets/mobirise/css/mbr-additional.css"><link rel="stylesheet" href="assets/mobirise/css/mbr-additional.css" type="text/css">
  
 

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.19.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0"></script>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #c12c1f;
            --secondary-color: #e6a23c;
            --accent-color: #d63031;
            --bg-light: #f5f5f5;
            --bg-dark: #1a1a1a;
            --text-light: #333;
            --text-dark: #f0f0f0;
            --shadow-color: ;
            
            /* 皮影角色顏色 */
            --puppet-head-color: ;
            --puppet-body-color: ;
            --puppet-waist-color: ;
            --puppet-arm-color: ;
            --puppet-leg-color: ;
            
            --stage-color: #f8e0c5;
            --joint-color: #ffd700;
            --indicator-bg: ;
            --border-radius: ;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: var(--bg-light);
            color: var(--text-light);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
            line-height: 1.6;
        }

        .dark body {
            background-color: var(--bg-dark);
            color: var(--text-dark);
        }

        header {
            width: 100%;
            padding: 1.5rem;
            background: linear-gradient(135deg, var(--puppet-head-color), var(--puppet-body-color));
            color: white;
            text-align: center;
            box-shadow: );
            position: relative;
            z-index: 10;
        }

        header h1 {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 2px;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            padding: 2rem 1rem;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
        }

        .game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 2rem;
            width: 100%;
        }

        .stage-container {
            flex: 1;
            min-width: 300px;
            max-width: 658px;
            position: relative;
        }

        .stage {
            position: relative;
            width: 100%;
            height: 370px;
            background-image: url('background.jpg');
            background-size: cover;
            background-position: center;
            border: 12px solid #5a3921;
            border-radius: var(--border-radius);
            box-shadow: 
                ,
                inset 0 0 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .stage::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0.1) 0%,
                rgba(0, 0, 0, 0.3) 100%
            );
            pointer-events: none;
            z-index: 1;
        }

        .stage-title {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background-color:white;
            color: red;
            padding: 0.5rem 1.5rem;
            border-radius: 30px;
            font-weight: bold;
            box-shadow:2px 2px 2px 1px white ;
            z-index: 5;
            font-size: 1.1rem;
        }

        .indicator {
            position: absolute;
            background-color: var(--indicator-bg);
            color: white;
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 25;
            text-align: center;
            box-shadow: ;
            min-width: 100px;
        }
        
        .accuracy-indicator {
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .jump-indicator {
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
        }

        .puppet {
            position: absolute;
            width: 150px;
            height: 300px;
            bottom: 50px;
            left: calc(50% - 75px);
            z-index: 10;
            transition: transform 0.1s ease-out;
            filter: drop-shadow(2px 4px 6px rgba(0, 0, 0, 0.4));
        }

        .puppet-head, .puppet-body, .puppet-waist, 
        .puppet-upper-legs, .puppet-lower-legs {
            position: absolute;
            border-radius: 4px;
        }

        .puppet-head {
            width: 72px;
            height: 59px;
            top: 10px;
            left: 25px;
            border-radius: 20px 20px 10px 10px;
            background-image: url("head.png");
            transform-origin: bottom center;
            z-index: 15;
            box-shadow: ;
        }

        .puppet-body {
            width: 44px;
            height: 109px;
            top: 50px;
            left: 40px;
            background-image: url("upper_body.png");
            transform-origin: top center;
            z-index: 10;
            box-shadow: ;
        }

        .puppet-waist {
            width: 64px;
            height: 76px;
            top: 110px;
            left: 30px;
            transform-origin: top center;
            transition: transform 0.2s ease;
            background-image: url("lower_body.png");
            z-index: 9;
            box-shadow: ;
        }

        .joint-point {
            position: absolute;
            width: 0px;
            height: 0px;
            background-color: var(--joint-color);
            border-radius: 0%;
            z-index: 20;
            box-shadow: ;
        }

        .arm-segment {
            position: absolute;
            transition: transform 0.2s ease;
        }

        .arm-container {
            position: absolute;
            z-index: 12;
        }

        .left-arm-container {
            top: 60px;
            left: 50px;
            width: 0px;
            height: 0px;
            transform-origin: top left;
        }

        .right-arm-container {
            top: 60px;
            right:60px;
            width:0px;
            height: 0px;
            transform-origin: top right;
        }

        .puppet-left-upper-arm, .puppet-right-upper-arm {
            width: 64px;
            height: 76px;
            background-image: url("upper_arm.png");
            top: 0px;
            left:0px;
            border-radius: 0px;
            transform-origin: top center;
            box-shadow: ;
        }

        .puppet-right-upper-arm {
            right: 0px;
            left: auto;
        }

        .puppet-left-forearm, .puppet-right-forearm {
            width: 69px;
            height: 89px;
            top: 50px;
            left: -10px;
            background-image: url("forearm.png");
            border-radius: 0px;
            transform-origin: top center;
            box-shadow: ;
        }

        .puppet-right-forearm {
            right: 0px;
            left: auto;
        }

        .leg-container {
            position: absolute;
            transform-origin: top center;
            z-index: 8;
        }

        .left-leg-container {
            top: 135px;
            left: 90px;
            height: 110px;
            width: 20px;
        }

        .right-leg-container {
            top: 135px;
            right: 70px;
            height: 110px;
            width: 20px;
        }

        .puppet-left-upper-leg, .puppet-right-upper-leg {
            width: 78px;
            height: 37px;
            background-image: url("leg.png");
            top: 40px;
            left: -40px;
            border-radius: 0px;
            box-shadow: ;
        }

        .puppet-right-upper-leg {
            right: 0;
            left: auto;
        }

        .puppet-left-lower-leg, .puppet-right-lower-leg {
            width: 0px;
            height: 0px;
            top: 50px;
            left: 1px;
            background-color: var(--puppet-leg-color);
            border-radius: 0px;
            transform-origin: top center;
            box-shadow: ;
        }

        .puppet-right-lower-leg {
            right: 1px;
            left: auto;
        }

        .webcam-container {
            flex: 1;
            min-width: 300px;
            max-width: 640px;
            position: relative;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: ;
        }

        #webcam {
            width: 100%;
            height: auto;
            transform: scaleX(-1);
            display: block;
        }
        
        #webcam-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
        }
        
        .camera-joint {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 800px;
            padding: 1rem;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: var(--border-radius);
            box-shadow:;
        }

        .dark .controls {
            background-color: rgba(30, 30, 30, 0.8);
        }

        button {
            padding: 0.75rem 1.75rem;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: ;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow:;
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: linear-gradient(135deg, #b5b5b5, #999999);
            cursor: not-allowed;
            transform: none !important;
        }

        .joint-toggle {
            display: flex;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 30px;
            box-shadow: ;
        }

        .dark .joint-toggle {
            background-color: rgba(50, 50, 50, 0.7);
        }

        .joint-toggle label {
            margin-left: 0.5rem;
            cursor: pointer;
            font-weight: 500;
        }

        .status {
            width: 100%;
            max-width: 800px;
            padding: 1.25rem;
            text-align: center;
            border-radius: var(--border-radius);
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: ;
            font-size: 1.05rem;
        }

        .dark .status {
            background-color: rgba(30, 30, 30, 0.8);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 1.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .instructions {
            width: 100%;
            max-width: 800px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 1.75rem;
            border-radius: var(--border-radius);
            box-shadow: );
        }

        .dark .instructions {
            background-color: rgba(30, 30, 30, 0.85);
        }

        .instructions h2 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.5rem;
            font-weight: 700;
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 0.5rem;
            font-family: 'Ma Shan Zheng', cursive;
        }

        .instructions p {
            margin-bottom: 0.75rem;
            line-height: 1.7;
        }

        .instructions ol {
            padding-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .instructions li {
            margin-bottom: 0.5rem;
        }
        
        .skeleton-colors {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            width: 100%;
            max-width: 800px;
            padding: 1rem;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: var(--border-radius);
            box-shadow: ;
        }

        .dark .skeleton-colors {
            background-color: rgba(30, 30, 30, 0.8);
        }

        .color-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 20px;
            box-shadow: ;
        }

        .dark .color-item {
            background-color: rgba(50, 50, 50, 0.7);
        }

        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 0.75rem;
            display: inline-block;
            box-shadow: ;
        }

        .tracking-quality {
            position: absolute;
            top: 15px;
            right: 15px;
            background: );
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: ;
            display: none;
        }

        .tracking-good {
            background: ;
        }
        
        .tracking-medium {
            background: ;
        }
        
        .tracking-poor {
            background: ;
        }

        footer {
            width: 100%;
            padding: 1.5rem;
            text-align: center;
            margin-top: auto;
            background: linear-gradient(135deg, var(--puppet-head-color), var(--puppet-body-color));
            color: white;
            font-size: 1rem;
            box-shadow: ;
        }

        footer p {
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* 回應式設計 */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 1.5rem 1rem;
                gap: 1.5rem;
            }
            
            .stage {
                height: 350px;
            }
            
            .puppet {
                width: 120px;
                height: 240px;
                left: calc(50% - 60px);
            }
            
            .instructions {
                padding: 1.5rem;
            }
        }

        @media (max-width: 480px) {
            header h1 {
                font-size: 1.8rem;
            }
            
            .stage {
                height: 250px;
            }
            
            .puppet {
                width: 90px;
                height: 180px;
                left: calc(50% - 45px);
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            button {
                width: 100%;
            }
            
            .instructions {
                padding: 1.25rem;
            }
        }
    </style>
  
  
  
</head>
<body>
  
  <section data-bs-version="5.1" class="menu menu2 cid-tJ9qx6u8Uh" once="menu" id="menu2-d">
    
    <nav class="navbar navbar-dropdown navbar-fixed-top navbar-expand-lg">
        <div class="container">
            <div class="navbar-brand">
                <span class="navbar-logo">
                    <a href="http://www.clctmc.edu.hk">
                        <img src="assets/images/school-logo-create-outline-96x119.png" alt="Mobirise Website Builder" style="height: 3rem;">
                    </a>
                </span>
                <span class="navbar-caption-wrap"><a class="navbar-caption text-black text-primary display-7" href="http://www.clctmc.edu.hk">圓玄學院妙法寺內明陳呂重德紀念中學</a></span>
            </div>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbarSupportedContent" data-bs-target="#navbarSupportedContent" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
                <div class="hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav nav-dropdown" data-app-modern-menu="true"><li class="nav-item"><a class="nav-link link text-black text-primary display-4" href="index.html">主頁</a></li>
                    <li class="nav-item"><a class="nav-link link text-black text-primary display-4" href="page2.html">皮影戲的歷史</a></li>
                    <li class="nav-item"><a class="nav-link link text-black text-primary display-4" href="page3.html">皮影戲的藝術</a>
                    </li></ul>
                
                <div class="navbar-buttons mbr-section-btn"><a class="btn btn-danger display-4" href="page4.html">
                        創新體驗</a></div>
            </div>
        </div>
    </nav>
</section><section class="display-7" style="padding: 0;align-items: center;justify-content: center;flex-wrap: wrap;    align-content: center;display: flex;position: relative;height: 4rem;"><a href="https://mobiri.se/2110839" style="flex: 1 1;height: 4rem;position: absolute;width: 100%;z-index: 1;"><img alt="" style="height: 4rem;" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="></a><p style="margin: 0;text-align: center;" class="display-7">&#8204;</p><a style="z-index:1" href="https://mobirise.com">Mobirise </a></section><script src="assets/bootstrap/js/bootstrap.bundle.min.js"></script>  <script src="assets/smoothscroll/smooth-scroll.js"></script>  <script src="assets/ytplayer/index.js"></script>  <script src="assets/dropdown/js/navbar-dropdown.js"></script>  <script src="assets/theme/js/script.js"></script>  
  <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <p>正在加載皮影戲遊戲...</p>
    </div>

	<br/><br/><br/><br/>

    <div class="container">
        <div class="game-area">
            <div class="stage-container">
                <div class="stage-title">皮影舞臺</div>
                <div class="stage">
                    <div class="puppet" id="puppet">
                        <div class="indicator accuracy-indicator" id="accuracyIndicator"></div>
                        <div class="indicator jump-indicator" id="jumpIndicator"></div>
                        
                        <div class="puppet-head" id="head"></div>
                        <div class="puppet-body" id="body"></div>
                        <div class="puppet-waist" id="waist"></div>
                        
                        <!-- 左臂 -->
                        <div class="arm-container left-arm-container" id="leftArmContainer">
                            <div class="arm-segment puppet-left-upper-arm" id="leftUpperArm"></div>
                            <div class="arm-segment puppet-left-forearm" id="leftForearm"></div>
                            <div class="joint-point" id="leftElbowPoint"></div>
                        </div>
                        
                        <!-- 右臂 -->
                        <div class="arm-container right-arm-container" id="rightArmContainer">
                            <div class="arm-segment puppet-right-upper-arm" id="rightUpperArm"></div>
                            <div class="arm-segment puppet-right-forearm" id="rightForearm"></div>
                            <div class="joint-point" id="rightElbowPoint"></div>
                        </div>
                        
                        <!-- 左腿 -->
                        <div class="leg-container left-leg-container" id="leftLegContainer">
                            <div class="arm-segment puppet-left-upper-leg" id="leftUpperLeg"></div>
                            <div class="arm-segment puppet-left-lower-leg" id="leftLowerLeg"></div>
                            <div class="joint-point" id="leftKneePoint"></div>
                        </div>
                        
                        <!-- 右腿 -->
                        <div class="leg-container right-leg-container" id="rightLegContainer">
                            <div class="arm-segment puppet-right-upper-leg" id="rightUpperLeg"></div>
                            <div class="arm-segment puppet-right-lower-leg" id="rightLowerLeg"></div>
                            <div class="joint-point" id="rightKneePoint"></div>
                        </div>
                        
                        <!-- 關節點 -->
                        <div class="joint-point" id="leftShoulderPoint"></div>
                        <div class="joint-point" id="rightShoulderPoint"></div>
                        <div class="joint-point" id="waistPoint"></div>
                        <div class="joint-point" id="leftHipPoint"></div>
                        <div class="joint-point" id="rightHipPoint"></div>
                        
                        <!-- 跟蹤品質指示器 -->
                        <div class="tracking-quality" id="trackingQuality"></div>
                    </div>
                </div>
            </div>

            <div class="webcam-container">
                <video id="webcam" autoplay playsinline></video>
                <canvas id="webcam-canvas"></canvas>
                <div id="camera-joints-container"></div>
            </div>
        </div>

        <div class="controls">
            <button id="startButton">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                </svg>
                開始遊戲
            </button>
            <button id="stopButton" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v4a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v4a.5.5 0 0 0 1 0V6z"/>
                    <path d="M14 0a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h12zM2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H2z"/>
                </svg>
                停止遊戲
            </button>
            <div class="joint-toggle">
                <input type="checkbox" id="showJoints" checked>
                <label for="showJoints">顯示關節點</label>
            </div>
        </div>

        <div class="status" id="statusMessage">
            請點擊「開始遊戲」按鈕，允許使用攝像頭來控制皮影戲角色。
        </div>

        <div class="instructions">
            <h2>如何遊玩</h2>
            <ol>
                <li>點擊「開始遊戲」按鈕，並允許瀏覽器使用您的攝像頭。</li>
                <li>站在攝像頭前，確保您的上半身可見。</li>
                <li>通過您的肢體動作來控制皮影戲角色：</li>
                <li>移動手臂控制角色的上臂和前臂，可實現垂直向上等全範圍運動</li>
                <li>彎曲腰部使角色的腰部活動</li>
                <li>移動腿部控制角色的上腿和下腿</li>
                <li>向左右移動使角色跟隨您的動作</li>
                <li>上下移動使角色也隨之上下移動</li>      
                <li>攝像頭畫面上的彩色點和線表示檢測到的身體關節，不同顏色代表不同關節</li>
                <li>享受傳統皮影戲的樂趣！</li>
            </ol>
        </div>
        
        <div class="skeleton-colors">
            <div class="color-item">
                <span class="color-box" style="background-color: #FF0000;"></span>
                <span>鼻子</span>
            </div>
            <div class="color-item">
                <span class="color-box" style="background-color: #00FF00;"></span>
                <span>左肩</span>
            </div>
            <div class="color-item">
                <span class="color-box" style="background-color: #0000FF;"></span>
                <span>右肩</span>
            </div>
            <div class="color-item">
                <span class="color-box" style="background-color: #FFFF00;"></span>
                <span>左肘</span>
            </div>
            <div class="color-item">
                <span class="color-box" style="background-color: #FF00FF;"></span>
                <span>右肘</span>
            </div>
            <div class="color-item">
                <span class="color-box" style="background-color: #00FFFF;"></span>
                <span>左腕</span>
            </div>
            <div class="color-item">
                <span class="color-box" style="background-color: #FF8000;"></span>
                <span>右腕</span>
            </div>
            <div class="color-item">
                <span class="color-box" style="background-color: #8000FF;"></span>
                <span>左髖</span>
            </div>
            <div class="color-item">
                <span class="color-box" style="background-color: #0080FF;"></span>
                <span>右髖</span>
            </div>
        </div>
    </div>
    <script>
        // 檢測暗黑模式偏好
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // DOM 元素
        const loadingOverlay = document.getElementById('loadingOverlay');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const statusMessage = document.getElementById('statusMessage');
        const webcamElement = document.getElementById('webcam');
        const webcamCanvas = document.getElementById('webcam-canvas');
        const puppet = document.getElementById('puppet');
        const showJointsCheckbox = document.getElementById('showJoints');
        const trackingQuality = document.getElementById('trackingQuality');
        const accuracyIndicator = document.getElementById('accuracyIndicator');
        const jumpIndicator = document.getElementById('jumpIndicator');
        
        // 身體部位元素
        const head = document.getElementById('head');
        const body = document.getElementById('body');
        const waist = document.getElementById('waist');
        
        // 左右手臂容器和部件
        const leftArmContainer = document.getElementById('leftArmContainer');
        const rightArmContainer = document.getElementById('rightArmContainer');
        const leftUpperArm = document.getElementById('leftUpperArm');
        const leftForearm = document.getElementById('leftForearm');
        const rightUpperArm = document.getElementById('rightUpperArm');
        const rightForearm = document.getElementById('rightForearm');
        
        // 左右腿容器和部件
        const leftLegContainer = document.getElementById('leftLegContainer');
        const rightLegContainer = document.getElementById('rightLegContainer');
        const leftUpperLeg = document.getElementById('leftUpperLeg');
        const leftLowerLeg = document.getElementById('leftLowerLeg');
        const rightUpperLeg = document.getElementById('rightUpperLeg');
        const rightLowerLeg = document.getElementById('rightLowerLeg');
        
        // 關節點元素
        const jointPoints = document.querySelectorAll('.joint-point');
        
        // 全域變數
        let detector;
        let videoWidth, videoHeight;
        let animationFrameId;
        let isRunning = false;
        let canvasCtx;
        let overallTrackingScore = 0;
        let lastPose = null;
        let smoothingFactor = 0.5; // 平滑因數，值越大越平滑但回應越慢
        
        // 跳躍檢測變數
        let baselineY = 0;
        let isJumping = false;
        let jumpCount = 0;
        let lastJumpTime = 0;
        let jumpRate = 0;
        
        // 姿勢置信度閾值
        const CONFIDENCE_THRESHOLD = {
            LOW: 0.3,
            MEDIUM: 0.5,
            HIGH: 0.7
        };

        // 初始化應用
        async function init() {
            try {
                // 載入 MoveNet 模型
                statusMessage.textContent = "正在加載模型...";
                const model = poseDetection.SupportedModels.MoveNet;
                const detectorConfig = {
                    modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                    enableSmoothing: true
                };
                detector = await poseDetection.createDetector(model, detectorConfig);
                
                // 初始化畫布上下文
                canvasCtx = webcamCanvas.getContext('2d');
                
                loadingOverlay.style.display = 'none';
                statusMessage.textContent = "模型已加載完成，請點擊「開始遊戲」按鈕。";
                
                // 初始化關節點顯示狀態
                updateJointPointsVisibility();
            } catch (error) {
                console.error('初始化錯誤:', error);
                statusMessage.textContent = `初始化錯誤: ${error.message}`;
                loadingOverlay.style.display = 'none';
            }
        }

        // 開始攝像頭和遊戲
        async function startGame() {
            if (!detector) {
                statusMessage.textContent = "模型尚未加載完成，請稍候。";
                return;
            }

            try {
                // 啟動攝像頭
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                webcamElement.srcObject = stream;

                // 等待視頻準備就緒
                await new Promise(resolve => {
                    webcamElement.onloadeddata = () => {
                        resolve();
                    };
                });

                videoWidth = webcamElement.videoWidth;
                videoHeight = webcamElement.videoHeight;
                
                // 設置Canvas尺寸與視頻匹配
                webcamCanvas.width = videoWidth;
                webcamCanvas.height = videoHeight;
                
                // 更新UI
                startButton.disabled = true;
                stopButton.disabled = false;
                statusMessage.textContent = "遊戲運行中！通過身體動作控制皮影戲角色。";
                isRunning = true;

                // 顯示跟蹤品質指示器和置信度
                trackingQuality.style.display = 'block';
                accuracyIndicator.style.display = 'block';
                jumpIndicator.style.display = 'block';
                
                // 重置跳躍統計
                jumpCount = 0;
                lastJumpTime = Date.now();
                jumpRate = 0;

                // 開始檢測迴圈
                detectPoseInRealTime();
            } catch (error) {
                console.error('開始遊戲錯誤:', error);
                statusMessage.textContent = `無法訪問攝像頭: ${error.message}`;
            }
        }

        // 停止遊戲和攝像頭
        function stopGame() {
            if (webcamElement.srcObject) {
                webcamElement.srcObject.getTracks().forEach(track => {
                    track.stop();
                });
                webcamElement.srcObject = null;
            }

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // 清空Canvas
            if (canvasCtx) {
                canvasCtx.clearRect(0, 0, webcamCanvas.width, webcamCanvas.height);
            }

            // 隱藏跟蹤品質指示器和置信度指示器
                trackingQuality.style.display = 'none';
                accuracyIndicator.style.display = 'none';
                jumpIndicator.style.display = 'none';

                // 重置角色位置和姿勢
                puppet.style.transform = `translate(0, 0)`;
                head.style.transform = 'rotate(0deg)';
                body.style.transform = 'rotate(0deg)';
                waist.style.transform = 'rotate(0deg)';
                
                leftArmContainer.style.transform = 'rotate(0deg)';
                leftForearm.style.transform = 'rotate(0deg)';
                rightArmContainer.style.transform = 'rotate(0deg)';
                rightForearm.style.transform = 'rotate(0deg)';
                
                leftLegContainer.style.transform = 'rotate(0deg)';
                leftLowerLeg.style.transform = 'rotate(0deg)';
                rightLegContainer.style.transform = 'rotate(0deg)';
                rightLowerLeg.style.transform = 'rotate(0deg)';

                // 更新UI
                startButton.disabled = false;
                stopButton.disabled = true;
                statusMessage.textContent = "遊戲已停止。";
                isRunning = false;
                lastPose = null;
                
                // 重置跳躍相關變數
                baselineY = 0;
                isJumping = false;
                jumpCount = 0;
                lastJumpTime = 0;
                jumpRate = 0;
            }

            // 更新關節點可見性
            function updateJointPointsVisibility() {
                const showJoints = showJointsCheckbox.checked;
                jointPoints.forEach(point => {
                    point.style.display = showJoints ? 'block' : 'none';
                });
            }

            // 更新指示器顯示
            function updateIndicators(accuracy, jumpRate) {
                // 更新右上角質量指示器
                trackingQuality.textContent = ``;
                trackingQuality.classList.remove('tracking-good', 'tracking-medium', 'tracking-poor');
                
                if (accuracy >= CONFIDENCE_THRESHOLD.HIGH) {
                    trackingQuality.classList.add('tracking-good');
                } else if (accuracy >= CONFIDENCE_THRESHOLD.MEDIUM) {
                    trackingQuality.classList.add('tracking-medium');
                } else {
                    trackingQuality.classList.add('tracking-poor');
                }
                
                // 更新指示器
                accuracyIndicator.textContent = ``;
                jumpIndicator.textContent = ``;
            }

            // 檢測跳躍
            function detectJump(pose) {
                if (!pose) return;
                
                const leftShoulder = findKeypoint(pose.keypoints, 'left_shoulder');
                const rightShoulder = findKeypoint(pose.keypoints, 'right_shoulder');
                
                if (!leftShoulder || !rightShoulder || 
                    leftShoulder.score < CONFIDENCE_THRESHOLD.MEDIUM || 
                    rightShoulder.score < CONFIDENCE_THRESHOLD.MEDIUM) {
                    return;
                }
                
                // 用肩膀位置的平均Y值來確定上下移動
                const currentY = (leftShoulder.y + rightShoulder.y) / 2;
                
                // 初始化基準Y值
                if (baselineY === 0) {
                    baselineY = currentY;
                    return;
                }
                
                // 檢測跳躍 - 當位置比基準高出一定值，且之前不在跳躍狀態
                const jumpThreshold = videoHeight * 0.10; // 10% 的視頻高度作為跳躍閾值
                
                if (!isJumping && (baselineY - currentY) > jumpThreshold) {
                    isJumping = true;
                    jumpCount++;
                    
                    // 更新跳躍率 - 每分鐘跳躍次數，限制在0-100之間
                    const now = Date.now();
                    const timeElapsed = (now - lastJumpTime) / 1000; // 秒數
                    
                    if (timeElapsed > 0) {
                        // 計算每分鐘跳躍次數
                        const jumpsPerMinute = (jumpCount / timeElapsed) * 60;
                        
                        // 標準化為0-100的百分比 (假設正常人每分鐘最多能跳50次)
                        jumpRate = Math.min(100, (jumpsPerMinute / 50) * 100);
                    }
                } 
                // 當回到接近基準位置，重置跳躍狀態
                else if (isJumping && Math.abs(baselineY - currentY) < jumpThreshold * 0.5) {
                    isJumping = false;
                    
                    // 逐漸更新基準位置，適應用戶高度變化
                    baselineY = baselineY * 0.8 + currentY * 0.2;
                }
                
                // 週期性更新基準值，以便適應用戶位置的漸變變化
                if (!isJumping) {
                    baselineY = baselineY * 0.99 + currentY * 0.01;
                }
            }

            // 平滑關鍵點，減少抖動
            function smoothKeypoints(newPose, lastPose) {
                if (!lastPose) return newPose;
                
                const smoothedKeypoints = [];
                
                for (let i = 0; i < newPose.keypoints.length; i++) {
                    const newKeypoint = newPose.keypoints[i];
                    const lastKeypoint = lastPose.keypoints.find(kp => kp.name === newKeypoint.name);
                    
                    if (lastKeypoint && newKeypoint.score > CONFIDENCE_THRESHOLD.LOW) {
                        smoothedKeypoints.push({
                            ...newKeypoint,
                            x: lastKeypoint.x * smoothingFactor + newKeypoint.x * (1 - smoothingFactor),
                            y: lastKeypoint.y * smoothingFactor + newKeypoint.y * (1 - smoothingFactor)
                        });
                    } else {
                        smoothedKeypoints.push(newKeypoint);
                    }
                }
                
                return {
                    ...newPose,
                    keypoints: smoothedKeypoints
                };
            }

            // 即時檢測姿勢並控制皮影角色
            async function detectPoseInRealTime() {
                if (!isRunning) return;

                try {
                    const poses = await detector.estimatePoses(webcamElement, { flipHorizontal: true });
                    
                    // 清空Canvas準備繪製
                    canvasCtx.clearRect(0, 0, webcamCanvas.width, webcamCanvas.height);
                    
                    if (poses.length > 0) {
                        // 平滑處理姿勢資料
                        const pose = smoothKeypoints(poses[0], lastPose);
                        lastPose = { ...pose }; // 保存當前姿勢用於下一幀平滑
                        
                        // 計算整體跟蹤品質得分
                        const keypoints = pose.keypoints;
                        let validPointsCount = 0;
                        let totalScore = 0;
                        
                        keypoints.forEach(keypoint => {
                            if (keypoint.score > CONFIDENCE_THRESHOLD.LOW) {
                                validPointsCount++;
                                totalScore += keypoint.score;
                            }
                        });
                        
                        if (validPointsCount > 0) {
                            overallTrackingScore = totalScore / keypoints.length;
                            // 檢測跳躍
                            detectJump(pose);
                            // 更新指示器
                            updateIndicators(overallTrackingScore, jumpRate);
                        } else {
                            updateIndicators(0, jumpRate);
                        }
                        
                        // 控制皮影角色
                        controlPuppet(pose);
                        
                        // 在攝像頭上顯示關節點和連接線
                        displaySkeletonAndJoints(pose);
                    } else {
                        updateIndicators(0, jumpRate);
                    }
                } catch (error) {
                    console.error('檢測姿勢錯誤:', error);
                    updateIndicators(0, jumpRate);
                }

                animationFrameId = requestAnimationFrame(detectPoseInRealTime);
            }
            
            // 繪製骨架和關節點，更接近參考圖片中的顏色
            function displaySkeletonAndJoints(pose) {
                const container = document.getElementById('camera-joints-container');
                const webcamRect = webcamElement.getBoundingClientRect();
                
                // 清除之前的關節點
                container.innerHTML = '';
                
                // 只在選擇顯示關節點時繪製
                if (!showJointsCheckbox.checked) return;
                
                // 關鍵點名稱和顏色映射
                const keypointColors = {
                    nose: '#FF0000',
                    left_shoulder: '#00FF00',
                    right_shoulder: '#0000FF',
                    left_elbow: '#FFFF00',
                    right_elbow: '#FF00FF',
                    left_wrist: '#00FFFF',
                    right_wrist: '#FF8000',
                    left_hip: '#8000FF',
                    right_hip: '#0080FF',
                    left_knee: '#80FF00',
                    right_knee: '#FF0080',
                    left_ankle: '#00FF80',
                    right_ankle: '#8000FF'
                };
                
                // 骨架連接定義和顏色，更接近參考圖片中的連線顏色
                const skeletonConnections = [
                    ['left_shoulder', 'right_shoulder', '#3498DB'], 
                    ['left_shoulder', 'left_elbow', '#2ECC71'],     
                    ['right_shoulder', 'right_elbow', '#2ECC71'],   
                    ['left_elbow', 'left_wrist', '#F39C12'],        
                    ['right_elbow', 'right_wrist', '#F39C12'],      
                    ['left_shoulder', 'left_hip', '#9B59B6'],       
                    ['right_shoulder', 'right_hip', '#9B59B6'],     
                    ['left_hip', 'right_hip', '#3498DB'],           
                    ['left_hip', 'left_knee', '#E74C3C'],           
                    ['right_hip', 'right_knee', '#E74C3C'],         
                    ['left_knee', 'left_ankle', '#F1C40F'],         
                    ['right_knee', 'right_ankle', '#F1C40F']        
                ];
                
                // 創建關鍵點字典以便通過名稱查找
                const keypointDict = {};
                pose.keypoints.forEach(keypoint => {
                    keypointDict[keypoint.name] = keypoint;
                });
                
                // 1. 先繪製骨架連接線
                canvasCtx.lineWidth = 4;
                
                skeletonConnections.forEach(connection => {
                    const [p1Name, p2Name, color] = connection;
                    const p1 = keypointDict[p1Name];
                    const p2 = keypointDict[p2Name];
                    
                    if (p1 && p2 && p1.score > CONFIDENCE_THRESHOLD.LOW && p2.score > CONFIDENCE_THRESHOLD.LOW) {
                        canvasCtx.strokeStyle = color; // 使用指定的顏色
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(p1.x, p1.y);
                        canvasCtx.lineTo(p2.x, p2.y);
                        canvasCtx.stroke();
                    }
                });
                
                // 2. 在關節點上繪製彩色圓點 - 更接近參考圖片中的點
                pose.keypoints.forEach(keypoint => {
                    if (keypoint.score > CONFIDENCE_THRESHOLD.LOW) {
                        // 在Canvas上繪製圓點
                        const color = keypointColors[keypoint.name] || '#FFC107';
                        canvasCtx.fillStyle = color;
                        canvasCtx.beginPath();
                        
                        // 半徑根據置信度變化，更接近參考圖片中的大小
                        const radius = 6 + (keypoint.score * 4);
                        canvasCtx.arc(keypoint.x, keypoint.y, radius, 0, 2 * Math.PI);
                        canvasCtx.fill();
                        
                        // 為低置信度的點添加紅色邊框
                        if (keypoint.score < CONFIDENCE_THRESHOLD.MEDIUM) {
                            canvasCtx.strokeStyle = 'red';
                            canvasCtx.lineWidth = 2;
                            canvasCtx.stroke();
                        }
                        
                        // 創建DOM關節點（用於交互提示）
                        const joint = document.createElement('div');
                        joint.className = 'camera-joint';
                        
                        // 設置位置（按視頻的實際尺寸比例縮放）
                        const x = (keypoint.x / videoWidth) * webcamRect.width;
                        const y = (keypoint.y / videoHeight) * webcamRect.height;
                        
                        joint.style.left = `${x}px`;
                        joint.style.top = `${y}px`;
                        
                        // 設置顏色
                        joint.style.backgroundColor = color;
                        
                        // 添加名稱提示
                        joint.title = keypoint.name.replace('_', ' ') + ` (${Math.round(keypoint.score * 100)}%)`;
                        
                        // 設置大小 - 置信度越高，點越大
                        const size = 8 + (keypoint.score * 8); // 8px到16px
                        joint.style.width = `${size}px`;
                        joint.style.height = `${size}px`;
                        
                        // 為低置信度的點添加紅色邊框
                        if (keypoint.score < CONFIDENCE_THRESHOLD.MEDIUM) {
                            joint.style.borderColor = 'red';
                        }
                        
                        container.appendChild(joint);
                    }
                });
            }

            // 根據檢測到的姿勢控制皮影角色
            function controlPuppet(pose) {
                const keypoints = pose.keypoints;
                
                // 查找所需關鍵點
                const nose = findKeypoint(keypoints, 'nose');
                const leftShoulder = findKeypoint(keypoints, 'left_shoulder');
                const rightShoulder = findKeypoint(keypoints, 'right_shoulder');
                const leftElbow = findKeypoint(keypoints, 'left_elbow');
                const rightElbow = findKeypoint(keypoints, 'right_elbow');
                const leftWrist = findKeypoint(keypoints, 'left_wrist');
                const rightWrist = findKeypoint(keypoints, 'right_wrist');
                const leftHip = findKeypoint(keypoints, 'left_hip');
                const rightHip = findKeypoint(keypoints, 'right_hip');
                const leftKnee = findKeypoint(keypoints, 'left_knee');
                const rightKnee = findKeypoint(keypoints, 'right_knee');
                const leftAnkle = findKeypoint(keypoints, 'left_ankle');
                const rightAnkle = findKeypoint(keypoints, 'right_ankle');
                
                // 檢查是否有足夠的關鍵點來控制角色
                if (leftShoulder && rightShoulder && leftShoulder.score > CONFIDENCE_THRESHOLD.MEDIUM && rightShoulder.score > CONFIDENCE_THRESHOLD.MEDIUM) {
                    // 計算垂直位置（跳躍/下蹲）
                    const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;
                    const normalizedY = (shoulderY / videoHeight) * 100;
                    let verticalOffset = (normalizedY - 30) * 3; // 縮放以使運動更加明顯
                    verticalOffset = Math.max(-100, Math.min(100, verticalOffset)); // 限制範圍
                    
                    // 計算水準位置（左/右移動）
                    const shoulderX = (leftShoulder.x + rightShoulder.x) / 2;
                    const normalizedX = (shoulderX / videoWidth) * 100;
                    let horizontalOffset = (normalizedX - 50) * 2; // 縮放以使運動更加明顯
                    horizontalOffset = Math.max(-100, Math.min(100, horizontalOffset)); // 限制範圍
                    
                    // 應用移動到皮影角色
                    puppet.style.transform = `translate(${horizontalOffset}px, ${verticalOffset}px)`;
                    
                    // 控制頭部 - 如果鼻子檢測良好
                    if (nose && nose.score > CONFIDENCE_THRESHOLD.MEDIUM) {
                        const headAngle = calculateHeadAngle(nose, leftShoulder, rightShoulder);
                        head.style.transform = `rotate(${headAngle}deg)`;
                    }
                    
           // 控制左臂
    if (leftShoulder && leftElbow && leftShoulder.score > CONFIDENCE_THRESHOLD.MEDIUM && leftElbow.score > CONFIDENCE_THRESHOLD.MEDIUM) {
        // 計算從肩膀到肘部的角度
        const dx = leftElbow.x - leftShoulder.x;
        const dy = leftElbow.y - leftShoulder.y;
        
        // 計算上臂角度 - 弧度轉度數
        // 修改角度計算以適應皮影戲的視覺方向
        const angle = -(Math.atan2(dy, dx) * 180 / Math.PI) +95; // 減去90度調整方向
        
        // 應用角度
        leftArmContainer.style.transform = `rotate(${angle}deg)`;
        
        // 控制左前臂
        if (leftWrist && leftWrist.score > CONFIDENCE_THRESHOLD.MEDIUM) {
            // 計算從肘部到手腕的角度
            const dxWrist = leftWrist.x - leftElbow.x;
            const dyWrist = leftWrist.y - leftElbow.y;
            const forearmAngle = Math.atan2(dyWrist, dxWrist) * 180 / Math.PI ;
            
            // 計算前臂相對於上臂的角度差
            let relativeAngle = -(forearmAngle +angle)+45;
            
            // 標準化角度到 -180 到 180 範圍
            while (relativeAngle > 180) relativeAngle -= 360;
            while (relativeAngle < -180) relativeAngle += 360;
            
            
            // 反轉角度方向以匹配皮影戲視覺效果
            //relativeAngle = -relativeAngle;
            
            // 限制肘部彎曲角度
            
            //relativeAngle = Math.max(-150, Math.min(150, relativeAngle));
            
            
            // 應用相對角度到前臂
            leftForearm.style.transform = `rotate(${relativeAngle}deg)`;
        }
    }

    // 控制右臂 - 同樣的修改
    if (rightShoulder && rightElbow && rightShoulder.score > CONFIDENCE_THRESHOLD.MEDIUM && rightElbow.score > CONFIDENCE_THRESHOLD.MEDIUM) {
        const dx = rightElbow.x - rightShoulder.x;
        const dy = rightElbow.y - rightShoulder.y;
        const angle = -(Math.atan2(dy, dx) * 180 / Math.PI) +90;
        rightArmContainer.style.transform = `rotate(${angle}deg)`;
        
        if (rightWrist && rightWrist.score > CONFIDENCE_THRESHOLD.MEDIUM) {
            const dxWrist = rightWrist.x - rightElbow.x;
            const dyWrist = rightWrist.y - rightElbow.y;
            const forearmAngle = Math.atan2(dyWrist, dxWrist) * 180 / Math.PI ;
            
            let relativeAngle = -(forearmAngle +angle) -45+180 ;
            while (relativeAngle > 180) relativeAngle -= 360;
            while (relativeAngle < -180) relativeAngle += 360;
            //relativeAngle = -relativeAngle;
            //relativeAngle = Math.max(-150, Math.min(150, relativeAngle));
            
            rightForearm.style.transform = `rotate(${relativeAngle}deg)`;
        }
    }
                    
                    // 控制身體姿勢
                    if (leftShoulder && rightShoulder && leftHip && rightHip && 
                        leftShoulder.score > CONFIDENCE_THRESHOLD.MEDIUM && rightShoulder.score > CONFIDENCE_THRESHOLD.MEDIUM && 
                        leftHip.score > CONFIDENCE_THRESHOLD.MEDIUM && rightHip.score > CONFIDENCE_THRESHOLD.MEDIUM) {
                        
                        const shoulderMidpoint = {
                            x: (leftShoulder.x + rightShoulder.x) / 2,
                            y: (leftShoulder.y + rightShoulder.y) / 2
                        };
                        
                        const hipMidpoint = {
                            x: (leftHip.x + rightHip.x) / 2,
                            y: (leftHip.y + rightHip.y) / 2
                        };
                        
                        // 計算軀幹和腰部角度
                        const torsoAngle = calculateAngle(
                            { x: shoulderMidpoint.x, y: shoulderMidpoint.y - 10 }, // 上參考點
                            shoulderMidpoint,
                            hipMidpoint
                        );
                        
                        // 調整到適當的角度範圍 (-30 到 30 度比較自然)
                        const bodyRotation = Math.max(-30, Math.min(30, 180 - torsoAngle));
                        body.style.transform = `rotate(${bodyRotation * 0.5}deg)`; // 身體旋轉較小
                        
                        // 腰部角度 - 從身體的下部往下
                        const waistAngle = calculateAngle(
                            shoulderMidpoint,
                            hipMidpoint,
                            { x: hipMidpoint.x, y: hipMidpoint.y + 10 } // 下參考點
                        );
                        
                        // 調整腰部角度，考慮身體已經旋轉的部分
                        const waistRotation = Math.max(-30, Math.min(30, waistAngle - 180 - (bodyRotation * 0.5)));
                        waist.style.transform = `rotate(${waistRotation}deg)`;
                    }
                    
                    // 控制左腿
                    if (leftHip && leftKnee && leftHip.score > CONFIDENCE_THRESHOLD.MEDIUM && leftKnee.score > CONFIDENCE_THRESHOLD.MEDIUM) {
                        // 計算向量從髖部到膝蓋
                        const dx = leftKnee.x - leftHip.x;
                        const dy = leftKnee.y - leftHip.y;
                        
                        // 計算上腿角度
                        let leftUpperLegAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        // 適應人偶坐標系 (通常上腿垂直向下是0度)
                        let adjustedLegAngle = leftUpperLegAngle - 90;
                        
                        // 限制腿的角度範圍 (-60 到 90 度)，前60度後90度
                        adjustedLegAngle = Math.max(-60, Math.min(90, adjustedLegAngle));
                        
                        // 應用旋轉到整個左腿容器
                        leftLegContainer.style.transform = `rotate(${adjustedLegAngle}deg)`;
                        
                        // 控制左小腿相對于左大腿的角度
                        if (leftAnkle && leftAnkle.score > CONFIDENCE_THRESHOLD.MEDIUM) {
                            // 計算向量從膝蓋到腳踝
                            const dxLowerLeg = leftAnkle.x - leftKnee.x;
                            const dyLowerLeg = leftAnkle.y - leftKnee.y;
                            
                            // 計算小腿角度
                            let leftLowerLegAngle = Math.atan2(dyLowerLeg, dxLowerLeg) * 180 / Math.PI;
                            
                            // 計算小腿相對於大腿的角度差
                            let relativeLowerLegAngle = leftLowerLegAngle - leftUpperLegAngle;
                            
                            // 調整到 -180 到 180 度範圍
                            while (relativeLowerLegAngle > 180) relativeLowerLegAngle -= 360;
                            while (relativeLowerLegAngle < -180) relativeLowerLegAngle += 360;
                            
                            // 限制膝關節角度範圍 (通常膝蓋只能往一個方向彎曲，約0-150度)
                            relativeLowerLegAngle = Math.max(0, Math.min(150, relativeLowerLegAngle));
                            
                            // 應用小腿旋轉
                            leftLowerLeg.style.transform = `rotate(${relativeLowerLegAngle}deg)`;
                        }
                    }
                    
                    // 控制右腿
                    if (rightHip && rightKnee && rightHip.score > CONFIDENCE_THRESHOLD.MEDIUM && rightKnee.score > CONFIDENCE_THRESHOLD.MEDIUM) {
                        // 計算向量從髖部到膝蓋
                        const dx = rightKnee.x - rightHip.x;
                        const dy = rightKnee.y - rightHip.y;
                        
                        // 計算上腿角度
                        let rightUpperLegAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        // 適應人偶坐標系 (通常上腿垂直向下是0度)
                        let adjustedLegAngle = rightUpperLegAngle - 90;
                        
                        // 限制腿的角度範圍 (-60 到 90 度)，前60度後90度
                        adjustedLegAngle = Math.max(-60, Math.min(90, adjustedLegAngle));
                        
                        // 應用旋轉到整個右腿容器
                        rightLegContainer.style.transform = `rotate(${adjustedLegAngle}deg)`;
                        
                        // 控制右小腿相對於右大腿的角度
                        if (rightAnkle && rightAnkle.score > CONFIDENCE_THRESHOLD.MEDIUM) {
                            // 計算向量從膝蓋到腳踝
                            const dxLowerLeg = rightAnkle.x - rightKnee.x;
                            const dyLowerLeg = rightAnkle.y - rightKnee.y;
                            
                            // 計算小腿角度
                            let rightLowerLegAngle = Math.atan2(dyLowerLeg, dxLowerLeg) * 180 / Math.PI;
                            
                            // 計算小腿相對於大腿的角度差
                            let relativeLowerLegAngle = rightLowerLegAngle - rightUpperLegAngle;
                            
                            // 調整到 -180 到 180 度範圍
                            while (relativeLowerLegAngle > 180) relativeLowerLegAngle -= 360;
                            while (relativeLowerLegAngle < -180) relativeLowerLegAngle += 360;
                            
                            // 限制膝關節角度範圍 (通常膝蓋只能往一個方向彎曲，約0-150度)
                            relativeLowerLegAngle = Math.max(0, Math.min(150, relativeLowerLegAngle));
                            
                            // 應用小腿旋轉
                            rightLowerLeg.style.transform = `rotate(${relativeLowerLegAngle}deg)`;
                        }
                    }
                }
            }

            // 計算頭部角度
            function calculateHeadAngle(nose, leftShoulder, rightShoulder) {
                if (!nose || !leftShoulder || !rightShoulder) return 0;
                
                // 計算肩膀中點
                const shoulderMidpoint = {
                    x: (leftShoulder.x + rightShoulder.x) / 2,
                    y: (leftShoulder.y + rightShoulder.y) / 2
                };
                
                // 計算從肩膀中點到鼻子的向量
                const dx = nose.x - shoulderMidpoint.x;
                const dy = nose.y - shoulderMidpoint.y;
                
                // 計算頭部傾斜角度 (垂直向上為0度)
                let headAngle = Math.atan2(dx, -dy) * 180 / Math.PI;
                
                // 限制頭部旋轉範圍
                return Math.max(-30, Math.min(30, headAngle));
            }

            // 輔助函數：查找特定關鍵點
            function findKeypoint(keypoints, name) {
                return keypoints.find(keypoint => keypoint.name === name);
            }

            // 計算三點之間的角度（以度為單位）
            function calculateAngle(a, b, c) {
                const ab = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
                const bc = Math.sqrt(Math.pow(b.x - c.x, 2) + Math.pow(b.y - c.y, 2));
                const ac = Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
                const angle = Math.acos((ab*ab + bc*bc - ac*ac) / (2 * ab * bc)) * 180 / Math.PI;
                
                // 確定角度的方向 (順時針或逆時針)
                const crossProduct = (b.x - a.x) * (c.y - b.y) - (b.y - a.y) * (c.x - b.x);
                return crossProduct < 0 ? 360 - angle : angle;
            }

            // 事件監聽器
            startButton.addEventListener('click', startGame);
            stopButton.addEventListener('click', stopGame);
            showJointsCheckbox.addEventListener('change', updateJointPointsVisibility);

            // 初始化應用
            document.addEventListener('DOMContentLoaded', init);
        </script>
  
</body>
</html>
